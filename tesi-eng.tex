\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[pdftex]{graphicx}
%\usepackage{pslatex}
\usepackage{listings}
%\usepackage{fancyhdr}
%\pagestyle{fancy}
%\usepackage{fullpage}

\lstset{basicstyle=\footnotesize}
\setlength{\parindent}{0pt}
\setlength{\parskip}{1.5ex plus 0.5ex minus 0.2ex}

%\setlength{\headheight}{8pt}

\begin{document}
%\topmargin = -0.5cm
\begin{titlepage}
\begin{center}

\textsc{\LARGE Università degli studi di Genova}\\[1.5cm]

\textsc{\large \bfseries Facoltà di Scienze Matematiche, Fisiche e Naturali}\\[0.3cm]
\textsc{\large \bfseries Corso di Laurea in Informatica}\\[0.5cm]

\includegraphics[width=0.15\textwidth]{./unige.jpg}\\[1cm]

Academic year 2008/2009

\textsc{\large Final project }\\[0.2cm]

\vspace{0.5cm}

% Title
{ 
\huge \bfseries Dynamic kernel instrumentation and applications to Computer Security
}\\[0.4cm]
 
\vspace{2cm}

% Author and supervisor
\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Candidate:}\\
Emanuele \textsc{Rocca}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Supervisor:} \\
Prof. Giuseppe \textsc{Ciaccio}
\end{flushright}
\end{minipage}

\vspace{2.0cm}
 
{\large October 20, 2009}
 
\end{center}

\end{titlepage}

\tableofcontents
\pagebreak

\section{Introduction}
Frameworks for dynamic tracing of operating systems allow to obtain in-depth
insights about kernel behaviour at runtime: they are mainly used by software
developers and system administrators, but indeed such systems also ease the job
of kernel developers, allowing them to debug their modifications without going
through tedious change-compile-reboot cycles. Furthermore, systems for dynamic
kernel instrumentation can be very interesting for students approaching the
complex and fascinating topic of operating systems, since they allow to study
and watch ``live'' the operation of a running kernel and the interactions
between various kernel subsystems.

In this final project we will try to show how the flexibility of this kind of
tools allows identifying possible break-in attempts in a relatively easy way:
to do that, we are going to develop kernel probes aimed at the identification
of some particular kinds of portscans and at providing the raw data needed for
developing a basic yet functional anomaly-based Intrusion Detection System.

The history of kernel dynamic tracing systems is quite recent. One of the first
comprehensive dynamic tracing framework is \textbf{DTrace}, developed by Sun
Microsystems and presented for the first time at the USENIX 2004 Annual
Technical Conference \cite{dtrace2004}: its usage among Sun Solaris and Mac OS
X system administrators and developers is widespread, and Sun Microsystems
often cite DTrace as one of the main features of their flagship operating
system.

Red Hat, IBM and Intel presented \textbf{SystemTap}, a software analogous to
DTrace but targeted at the Linux kernel, during the 2005 Ottawa Linux Symposium
\cite{vara2005}.

The main reason behind development of a brand new system, as opposed to porting
DTrace to Linux, is legal: even if DTrace is by all means Free Software, Sun
decided to release it under the terms of the Common Development and
Distribution License (CDDL), not compatible with the GNU General Public License
(GPL) under which the Linux kernel is released.

\subsection{Kernel dynamic tracing} 
\label{tracing:features}
Traditional performance analysis tools are oriented towards developers and
testers; they can therefore often be found in development and testing
environments, much more rarely in production systems. Quite often, though,
behavioural differences between test and production systems due to
configurations that cannot be replicated exactly or to unforeseen usage
patterns lead to the need of a precise system of analysis which has to be
reliable and without performance penalties.

To allow the analysis of a production operating system behaviour, a tool with
the following requirements is needed:

\begin{itemize}
    \item No impact on the system when disabled
    \item Easy extraction and elaboration of gathered data
    \item High level of security when enabled
\end{itemize}

The usage of static kernel probes, an approach followed for instance by the
\textbf{Linux Trace Toolkit}, influences kernel behaviour even when the tracing
system is not in use; therefore, it is not a viable choice because it does not
meet the first of the high level requirements we have formerly identified. On
the contrary, dynamically loadable kernel probes do not interfere with the
operating system, as they can simply be unloaded when kernel tracing is not
needed.

To allow easy extraction and elaboration of interesting data, the dynamic
tracing system needs to supply an ad-hoc high level scripting language and it
somehow has to hide operating system implementation details to users, who are
not necessarily kernel experts.

Alas, an high level of security is required. A user working with the tracing
system should of course not be allowed to induce kernel errors, for example
via infinite loops or divisions by zero.

\subsection{Applications to Computer Security}
Systems apt to identify break-in attempts, known as \emph{Intrusion Detection
System} or \textbf{IDS}, can be network-based or \emph{host-based}.

Being able to obtain detailed data about operating system behaviour at runtime
using a dynamic kernel tracing framework, we can develop the prototype of an
host-based ``hybrid'' IDS. We are going to follow an approach based on known
pattern of events associated with certain potentially malevolous behaviours,
such as portscans, as well as a radically different approach based on the
analysis of system calls sequences, as detailed in sections \ref{ids:portscan}
and \ref{ids:syscall}.

\pagebreak

\section{SystemTap}
SystemTap usage is relatively straightforward, as users are only required to
learn an high-level scripting language,  covered in detail in section
\ref{systemtap:language}, to be able to gather data about runtime kernel
behaviour.

However, in order to interact with the operating system kernel, user scripts
need to somehow be transformed into kernel modules, which can be loaded into
the kernel itself and than interact with user space. SystemTap's architecture,
explained in the following section, is heavily influenced by these
considerations.

\subsection{Architecture}
\begin{figure}[tb]
  \caption{High level SystemTap architecture}
  \centering
      \includegraphics{./pipeline.jpg}
\end{figure}

SystemTap is made by two main components: a front-end called \textbf{stap}
which takes care of building a kernel module from a SystemTap script, and a
back-end called \textbf{staprun} which loads the module, extracts the output
from kernel space and finally unloads the module from memory.

This kind of separation between the building and execution steps allows to
build scripts on a development machine with all the required debug information
and headers. The resulting module can then be loaded on a production system,
without changing its configuration and avoiding to install additional software.

The architectural organization of SystemTap can be seen as a pipeline
\cite{arch2005} organized in the following stages:

\begin{itemize}
    \item parse
    \item elaborate
    \item translate
    \item build
    \item load/run
    \item extract output/unload
\end{itemize}

Among the main front-end components, the so-called \textbf{translator} is
responsible for the first three pipeline stages: during \emph{parse} it
analyses the input script, elaborating it during the \emph{elaborate} phase and
finally translating it in a C program during the third phase, known as
\emph{translate} \cite{arch2005}.

In the \emph{build} stage, a kernel module is produced compiling the
aforementioned C program, this way concluding front-end operations.

Then the back-end takes control, loading the kernel module in the
\emph{load/run} stage and copying output data from kernel space to temporary
files in the \emph{extract output} stage, which terminates when the user
decides to stop probe execution or in the event of run-time errors, such as the
exceeding of maximun number of allowed iterations.
\footnote{See section \ref{systemtap:security} for further information about
limitations imposed by SystemTap to avoid reliability or security problems.}

As its very last operation, the back-end unloads the kernel module from memory
in the \emph{unload} stage.

\subsection{The Language}
\label{systemtap:language}
The SystemTap scripting language is a strongly typed, procedural language which
does not require to declare variables and is inspired by awk and dtrace
\cite{langref}.

Its main constructs are probes and functions: probes allow to identify certain
kernel events, like for example a syscall execution or the reception of a TCP
packet (which indeed corresponds to the execution of a given kernel function).
SystemTap functions, like those of any programming language, allow to write
modular and reusable code.

\subsubsection{Script types}
SystemTap discerns between two different script categories: \textbf{tapsets}
and \textbf{probes}. Tapsets are basically functions libraries and probe
aliases whose goal is to ease the process of writing probe scripts. Probes are
SystemTap scripts written by a user to reach a given objective.

For instance, during this final project we have developed a tapset called
portscan.stp containing various functions and probe aliases aimed at the
identification of certain types of portscans. Then we wrote a probe script that
gathers data about potentially anomalous behaviours and possible break-in
attempts: this script uses portscan.stp and other tapsets provided by
SystemTap\footnote{Among the many: io.stp for input/output, networking.stp for
network-related events, tcp.stp for TCP packets analysis.}.

\subsubsection{Defining new probes}
Defining a new probe means declaring it as an alias of an already existing one,
so that when the latter is triggered by some kernel event the former is
triggered as well, inheriting data and therefore allowing the user to extend
the aliased probe behaviour.

As an example, consider the following probe alias defining a probe named
\textbf{udp.sendmsg}, triggered by the \verb|udp_sendmsg| Linux kernel function,
responsible for sending UDP datagrams:

\begin{lstlisting}
/**
  * probe udp.sendmsg - Sending a UDP message  
  * @name: Name of this probe
  * @sock: Network socket 
  * @size: Number of bytes to send  
  *
  * Context:
  *   The process which sends a udp message 
  */
probe udp.sendmsg = kernel.function("udp_sendmsg") {
    name = "udp.sendmsg"
    sock    = $sk
    size    = $len
}
\end{lstlisting}

The socket \textbf{sk} and the integer \textbf{len} are two of the parameters
accepted by the kernel function \verb|udp_sendmsg|, and the probe udp.sendmsg
just exports them with the names of \textbf{sock} and \textbf{size}
respectively.

\subsubsection{SystemTap functions: an example}
Functions are defined using the \textbf{function} keyword: type definitions are
not necessary, as shown by the following example:

\begin{lstlisting}
function fibonacci(i)
{
  if (i < 1) return 0
  else if (i < 2) return 1
  else return fibonacci(i-1) + fibonacci(i-2)
}
\end{lstlisting}

\subsubsection{Statistics}
For a tool reacting to frequent events like those generated by an operating
system kernel it is very important to ease the collection of statistics in a
way that avoids the penalties of repeatedly exclusive locking the global
variables those numbers are being put into.  SystemTap provides a special
operator used to accumulate interesting values without locking and some
functions apt to extract statistical aggregates\cite{manstap}.

\pagebreak

The aggregation operator is \verb|<<<| and the following example illustrates
its usage:

\begin{lstlisting}
probe kernel.function("__kmalloc") { 
        kmalloc[execname()] <<< $size
}
\end{lstlisting}

\subsection{Reliability and Security}
\label{systemtap:security}
As already stated in section \ref{tracing:features}, reliability and security
are among the fundamental requirements of a kernel dynamic tracing system.
SystemTap implements various constraints and controls to avoid potentially
disastrous kernel space bugs.

\subsubsection{Memory, NULL pointers and divisions by zero}
Exhausting available memory is not possible as SystemTap does not allow dynamic
memory allocation. Arrays are statically allocated during probe initialization:
any attempt to instantiate arrays which are too big result in a compilation
error. Furthermore, the number of maximum array elements is limited to 2048, a
value which can be modified with the \verb|MAXMAPENTRIES| parameter.

During the \emph{translate} phase, it is front-end's responsibility to identify
potentially dangerous operations, adding C statements aimed at checking probe
arguments. This way, invalid operations such as NULL pointer access can be
identified in the \emph{load/run} phase, causing probe termination with an
explanatory error message.

\subsubsection{Infinite loops and recursion}
Another way to exhaust system resources, leading to an operating system crash,
is the execution of an infinite loop, both using an actual looping statement
such as a ``for'' cycle or by means of recursive calls without a statement
intended to eventually stop recursion.

SystemTap addresses this problem limiting the maximum number of allowed
recursive calls to 10. This limit can be changed using the \verb|MAXNESTING|
parameter. Similarly, \verb|MAXACTION| limits the number of executed statements
for every ``probe hit'' to 1000 by default. 

\subsubsection{Excessive load}
\label{systemtap:overload}
SystemTap also uses overload processing so that resource demanding probes, which
could slowdown the whole system, are automatically stopped when certain
thresholds are reached: if more than \verb|STP_OVERLOAD_THRESHOLD| cycles have
been spent in all the probes on a single cpu during the last
\verb|STP_OVERLOAD_INTERVAL| cycles, the probes have overloaded the system and
an exit is triggered\cite{manstap}.

Overload processing can be disabled altogether using the \verb|STP_NO_OVERLOAD|
parameter.

\pagebreak

\section{A Tapset for portscans identification}
\label{ids:portscan}
SystemTap comes with a number of tapsets developed by the community in order to
allow users to easily write scripts intended to accomplish common analysis
tasks, such as basic IP traffic monitoring. Those tapsets effectively hide from
the user actual kernel implementation details by means of associating a
``concept'', for example sending an Ethernet frame, to a set of kernel events.

In questo modo, in caso di riorganizzazione del codice del kernel, l'utente non
dovrà aggiornare i propri script, visto che la comunità che lavora su SystemTap
tiene costantemente aggiornati i tapset a corredo.

Basandoci sul tapset che si occupa del protocollo TCP abbiamo prodotto un
tapset che fornisce due sonde atte a individuare scansioni NULL, FIX, XMAS e
TCP Connect. Queste tipologie di scansione sono un sottoinsieme delle tecniche
di portscan adottate dal famoso scanner di rete \textbf{Nmap}.

\subsection{NULL, FIN and XMAS scans}
Per quanto concerne i primi tre tipi di portscan, l'individuazione tramite
SystemTap è banale: alla ricezione di un pacchetto TCP, mediante la sonda
tcp.receive, si controllano i flag impostati. Se nessuno dei flag TCP è
impostato si tratta di una scansione NULL, se è settato il solo flag FIN si
tratta di una FIN scan, se sia FIN che PSH che URG sono impostati si tratta di
una scansione di tipo XMAS.

La variabile name conterrà il nome del tipo di scansione NULL/FIN/XMAS
eventualmente identificata, stringa vuota altrimenti.

\begin{lstlisting}
/* NULL, FIN and XMAS scans are easy to catch */
probe portscan.nullfinxmas = tcp.receive {
    name = ""

    if (fin && psh && urg) name = "XMAS";

    if (!psh && !urg && !syn && !rst && !ack)
        name = fin ? "FIN" : "NULL";

    if (name == "") next;
}
\end{lstlisting}

\subsection{TCP Connect scans}
Riconoscere le scansioni di tipo TCP Connect non è immediato come nel caso
affrontato in precedenza: è infatti necessario individurare i socket TCP che
vengono chiusi senza che attraverso di essi siano effettivamente transitati dei
dati.

\subsubsection{Auxiliary functions}
\label{tcpsockstr}
Come prima cosa ci servono alcune funzioni atte a leggere i dati presenti nella
struttura \textbf{skb}, resa disponibile dalla sonda tcp.receive, contenuta nel
tapset tcp.

La prima delle funzioni che definiamo calcola la lunghezza del payload di un
dato pacchetto, la seconda costruisce una stringa di identificazione del socket
cui il pacchetto afferisce.

%[frame=tb]
\begin{lstlisting}
function __tcp_payload_len:long (skb) {
    tcphdr = __get_skb_tcphdr(skb)
    return @cast(skb, "sk_buff")->len - 
        @cast(tcphdr, "tcphdr")->doff * 4
}

function __tcp_sockstr:string (skb) {
    tcphdr = __get_skb_tcphdr(skb)
    dport = __tcp_skb_dport(tcphdr)
    sport = __tcp_skb_sport(tcphdr)

    iphdr = __get_skb_iphdr(skb)
    saddr = ip_ntop(__ip_skb_saddr(iphdr))
    daddr = ip_ntop(__ip_skb_daddr(iphdr))

    return sprintf("%s:%d %s:%d", saddr, sport, daddr, dport);
}
\end{lstlisting}

\subsubsection{Keeping track of open sockets}
Abbiamo bisogno di una struttura dati nella quale immagazzinare il numero di
byte di payload effettivamente transitati attraverso ogni socket. Decidiamo di
utilizzare un array associativo e come chiave scegliamo la stringa di
identificazione costruita come illustrato nella sezione \ref{tcpsockstr}.

Aggiorniamo la nostra struttura alla ricezione di pacchetti TCP col flag SYN
impostato, prima fase del \emph{three-way handshake}.

\begin{lstlisting}
global sockets
probe kernel.function("tcp_v4_syn_recv_sock") {
    sockets[__tcp_sockstr($skb)] = __tcp_payload_len($skb)
}
\end{lstlisting}

\subsubsection{Identifying sockets without network traffic}
Alla ricezione di un pacchetto TCP verifichiamo l'esistenza della
corrispondente stringa di identificazione del socket.

Nel caso in cui la dimensione del payload del pacchetto sia maggiore di 0
cancelliamo il socket corrispondente dalla nostra struttura dati in modo da
ignorare questo e i successivi eventi relativi al socket che stiamo
controllando.

Se il pacchetto sotto esame ha i flag ACK e RST impostati ci troviamo di fronte
ad una scansione di tipo TCP connect: il fatto che i due flag siano impostati
implica una richiesta di chiusura del socket e tutti gli eventuali pacchetti
ricevuti in precedenza avevano dimensione di payload a 0, altrimenti il socket
sarebbe stato cancellato dalla struttura dati e gli eventi successivi ignorati.

\begin{lstlisting}
probe portscan.tcpconnect = tcp.receive {
    sockstr = __tcp_sockstr($skb)
    if (!([sockstr] in sockets))
        next;

    sockets[sockstr] += __tcp_payload_len($skb)
    if (sockets[sockstr] > 0) {
        /* some data has actually been sent on this socket */
        delete sockets[sockstr]
        next;
    }

    if (ack && rst) {
        name = "TCP Connect"
        delete sockets[sockstr]
    }
    else
        next;
}
\end{lstlisting}

\pagebreak

\section{Anomaly Based Intrusion Detection Systems} 
L'approccio fin qui adottato per l'identificazione di possibili scansioni in
corso è simile a quello seguito dai cosiddetti \emph{Signature Based Intrusion
Detection Systems}. Tale categoria di IDS confronta il comportamento a runtime
del sistema con un database di comportamenti anomali noti: eventuali
corrispondenze vengono considerate come possibili attacchi.

Tra i punti deboli di questa categoria di IDS annoveriamo l'impossibilità di
individuare tutti gli attacchi la cui signature non è presente nel database, la
conseguente necessità di mantenere aggiornate le ``definizioni'' degli attacchi
noti e il rischio di non individuare il comportamento di tutti gli exploit
volutamente modificati per differire dalle definizioni.

Di contro, gli \emph{Anomaly Based Intrusion Detection Systems} considerano
come anomalo ogni comportamento che si discosta in qualche modo da quello
normale del sistema; tale categoria di IDS non necessita dunque di un database
di pattern anomali, ma piuttosto di una definzione di ``comportamento
normale''. Per quanto concerne gli IDS di rete il concetto di normalità può
essere definito basandosi sull'analisi dei payload dei pacchetti ricevuti,
mentre per i cosiddetti \emph{Host-based Intrusion Detection System} un metodo
per discernere tra comportamenti anomali e accettabili è l'analisi delle
sequenze di chiamate di sistema.

\subsection{Payload analysis}
La strada dell'analisi dei payload dei pacchetti ricevuti è stata seguita da
Wang e Stolfo \cite{wang}: in una prima fase di addestramento del sistema viene
analizzata la dimensione del payload dei pacchetti ricevuti sulle varie porte e
ne viene calcolata la deviazione standard. Questi dati vengono comparati con le
dimensioni dei payload dei pacchetti ricevuti a runtime e vengono generati
degli allarmi al superamento delle soglie di tolleranza impostate.

\subsection{Sequences of system calls analysis}
\label{ids:syscall}
Il prototipo di Intrusion Detection System sviluppato nel corso di questa prova
finale si basa sull'analisi di brevi sequenze di chiamate di sistema, approccio
teorizzato da Forrest et al \cite{forrest96}.

L'idea di fondo è di produrre una sorta di ``sistema immunitario'' per
calcolatori e per farlo è necessario riuscire a distinguere i comportamenti
normali da quelli anomali. Il lavoro svolto da Hofmeyr et al \cite{hofmeyr97}
dimostra empiricamente la validità dell'uso di sequenze di syscall come
discriminante tra comportamenti legittimi e illegittimi di un programma in
esecuzione.

L'approccio proposto consiste nel memorizzare in un database le sequenze uniche
di chiamate di sistema per ogni programma in esecuzione sulla macchina durante
un periodo di utilizzo normale del calcolatore. Una volta costruito questo
database sarà possibile confrontare le sequenze di syscall eseguite dai vari
processi con quelle ritenute normali, alla ricerca di eventuali pattern
anomali.

%\pagebreak 

\section{Implementing an Anomaly Based IDS}
A livello macroscopico, i due problemi principali da affrontare
nell'implementazione di un IDS basato sull'analisi delle sequenze di syscall
sono la creazione di un database di comportamenti normali e l'analisi dei
comportamenti in fase di esecuzione per riscontrare eventuali anomalie.

Come prerequisito per affrontare entrambi i problemi abbiamo individuato lo
sviluppo di uno strumento che produca le sequenze di syscall di una certa
lunghezza eseguite dai vari programmi; nella nostra implementazione questo
strumento è stato realizzato mediante una sonda SystemTap, descritta nel
dettaglio nella sezione \ref{ids:systemtap}.

L'output di questa sonda viene analizzato da alcuni script Python che si
occupano di costruire e rendere persistente il database di sequenze uniche,
come spiegato nella sezione \ref{ids:database}, nonché di scovare eventuali
pattern anomali a runtime (\ref{ids:runtime}).

\subsection{Generating sequences of system calls}
\subsubsection{Choosing sequences length}
La scelta della lunghezza delle sequenze da analizzare è particolarmente
delicata: come è ovvio siamo interessati ad avere sequenze il più corte
possibile, in modo da diminuire la dimensione del database e la computazione
necessaria in fase di esecuzione per identificare i comportamenti anomali.
D'altro canto, evidentemente, vogliamo sequenze sufficientemente lunghe da
permetterci di caratterizzare correttamente il comportamento dei programmi in
esame.

Hofmeyr et al \cite{hofmeyr97} concludono che sequenze di dieci syscall sono un
buon compromesso tra questi requisiti contrastanti, mentre Warrender et al
\cite{warrender99} notano che è possibile ottenere risultati soddisfacenti con
sequenze di lunghezza sei, migliorando sensibilmente le performance e
diminuendo la dimensione del database rispetto all'analisi di sequenze di
lunghezza dieci.

Nella nostra implementazione la scelta è lasciata all'utente tramite un
parametro di configurazione, il cui valore predefinito è 6: garantendo questa
scelta all'utente si rende necessaria l'implementazione di controlli volti ad
evitare l'utilizzo di un database di sequenze con lunghezza diversa dal valore
scelto per il parametro. Cambiandolo, infatti, si rende necessaria la
ricostruzione del database.

\subsubsection{Generating sequences with SystemTap}
\label{ids:systemtap}
Eccoci finalmente allo script SystemTap che si occupa di costruire tutte le
sequenze di syscall di una data lunghezza divise per eseguibile. Lo presentiamo
nella sua interezza, descrivendo poi passo passo le operazioni svolte.

\begin{lstlisting}
global values
global occurs

probe syscall.* {
    exec = execname()
    if (exec == "stap" || exec == "stapio")
        next;

    values[exec,occurs[exec]] = name
    occurs[exec]++

    if (occurs[exec] == $1) {
        printf("%s %d", exec, uid())

        for (i=0; i < $1; i++) {
            printf(" %s", values[exec,i])
            values[exec,i] = values[exec,i+1]
        }

        printf("\n");
        occurs[exec]--
    }
}
\end{lstlisting}

Lo script in questione è piuttosto breve ma ci permette di illustrare varie
caratteristiche di SystemTap. 

Gli eventi che vogliamo individuare sono, banalmente, le invocazioni di
chiamate di sistema. Il tapset syscalls.stp ci viene in aiuto, esponendo varie
sonde quali per esempio syscall.brk, syscall.chmod e così via.

Attendiamo dunque l'esecuzione di una qualunque chiamata di sistema, assegnando
alla variabile exec il nome dell'eseguibile e ignorando le syscall relative
agli eseguibili stap e stapio.

\begin{lstlisting}
probe syscall.* {
    exec = execname()
    if (exec == "stap" || exec == "stapio")
        next;
\end{lstlisting}

A questo punto memorizziamo nell'array associativo values il nome della
chiamata corrente; gli indici di values sono nell'ordine: il nome
dell'eseguibile che ha effettuato la determinata syscall e la posizione nella
sequenza della stessa. La posizione corrente viene mantenuta, per eseguibile,
nell'array occurs.

\begin{lstlisting}
    values[exec,occurs[exec]] = name
    occurs[exec]++
\end{lstlisting}

Come si diceva, la lunghezza delle sequenze è un parametro configurabile, che
passiamo allo script nella variabile \verb|$1|: raggiunta la lunghezza
desiderata scriviamo su standard output il nome dell'eseguibile, lo user id e
la sequenza identificata. Durante l'output della sequenza ci occupiamo inoltre
di fare scorrere verso sinistra la finestra.

\begin{lstlisting}
    if (occurs[exec] == $1) {
        printf("%s %d", exec, uid())

        for (i=0; i < $1; i++) {
            printf(" %s", values[exec,i])
            values[exec,i] = values[exec,i+1]
        }

        printf("\n");
        occurs[exec]--
    }
\end{lstlisting}

L'output ottenuto è di questo tipo:

\begin{lstlisting}
gnome-terminal 1000 gettimeofday poll gettimeofday gettimeofday write poll
gnome-terminal 1000 poll gettimeofday gettimeofday write poll poll
\end{lstlisting}

Nell'esempio, la lunghezza della sequenze è stata impostata a 6 e l'eseguibile
gnome-terminal ha invocato nell'ordine queste syscall:

\begin{itemize}
    \item gettimeofday
    \item poll 
    \item gettimeofday 
    \item gettimeofday 
    \item write 
    \item poll 
    \item poll
\end{itemize}

\subsection{Normal behaviour database}
\label{ids:database}
Per produrre il database dei comportamenti normali partiamo dunque dal copioso
output generato dalla sonda SystemTap di cui al punto \ref{ids:systemtap}, lo
analizziamo individuando le sequenze uniche e serializziamo i dati raccolti
mediante lo script Python che andiamo a descrivere.

\subsubsection{Generating unique sequences}
Lo script builddb.py si avvale di due moduli per assolvere il suo compito: il
primo di questi, reader.py, genera una struttura dati contenente le sequenze
uniche divise per eseguibile. La parte fondamentale di questa struttura è il
dizionario executables, che contiene i dati veri e propri divisi per
eseguibile; per esempio, si può accedere alle sequenze generate da firefox con:
\verb|executables['firefox']|.

Considerata la mole di dati da analizzare è importante assicurarsi di
utilizzare un metodo efficiente per generare l'insieme di sequenze uniche: per
questa ragione abbiamo pensato di implementare una classe generica che effettua
la lettura dell'input, lasciando a classi più specifiche l'implementazione del
metodo che si occupa di verificare se una data sequenza è già presente nel
database, così come l'inserimento di una sequenza "nuova".

Il metodo go() analizza ogni linea in input, chiamando il metodo
addseq(eseguibile, sequenza) che garantisce l'inserimento nel dizionario
executables descritto poc'anzi solo in caso di sequenza sconosciuta.

knownseq(eseguibile, sequenza), risulterà utile in fase di esecuzione, come
descritto nella sezione \ref{ids:runtime}.

\begin{lstlisting}[language=Python]
class SyscallDataReader(object):
    [ ... ]

    def go(self):
        while True:
            # Not using readlines() to allow unbuffered input
            input_line = self.input.readline()

            if not input_line:
                self.ending = time.time()
                break

            execname, uid, calls = line2data(input_line)
            self.addseq(execname, calls)

    def addseq(self, execname, calls):
        raise NotImplementedError

    def knownseq(self, execname, calls):
        raise NotImplementedError
\end{lstlisting}

Le varie specializzazioni si differenziano a seconda del tipo di struttura dati
usata per rappresentare i valori del dizionario executables.

L'implementazione mostratasi più efficiente si avvale della struttura dati set,
inclusa tra le strutture dati di base di Python. 

\begin{lstlisting}[language=Python]
class SetSyscallDataReader(SyscallDataReader):

    def addseq(self, execname, calls):
        if execname not in self.executables:
            self.executables[execname] = set([])

        self.executables[execname].add(calls)

    def knownseq(self, execname, calls):
        return calls in self.executables[execname]
\end{lstlisting}

Come si può notare, l'implementazione di un ``reader'' è questione di poche
righe, consentendo di sperimentare facilmente vari algoritmi e strutture dati.

A titolo d'esempio, la seguente implementazione usa la struttura dati list:

\begin{lstlisting}[language=Python]
class ListSyscallDataReader(SyscallDataReader):

    def addseq(self, execname, calls):
        if execname not in self.executables:
            self.executables[execname] = []

        if not self.knownseq(execname, calls):
            self.executables[execname].append(calls)

    def knownseq(self, execname, calls):
        return calls in self.executables[execname]
\end{lstlisting}

\subsubsection{Serialization}
dbaccess.py è il secondo modulo utilizzato dallo script per la costruzione del
database, e fornisce le funzioni utili a salvare su file e successivamente
caricare la struttura dati contenente le sequenze uniche raccolte.

\begin{lstlisting}[language=Python]
import os
import shutil
import cPickle

import config

def dbexists():
    return os.path.isfile(config.FILENAME)

def getdata():
    dbf = open(config.FILENAME, 'r')
    reader = cPickle.loads(dbf.read())
    dbf.close()
    return reader

def putdata(data):
    if dbexists():
        backup = config.FILENAME + ".old"
        print "Creating backup file", backup, "before saving database...",
        shutil.copy(config.FILENAME, backup)
        print "done."

    # can't pickle file objects
    data.input = None

    dbf = open(config.FILENAME, 'wb')
    cPickle.dump(data, dbf)
    dbf.close()
\end{lstlisting}

\subsection{Identifying anomalous behaviour}
\label{ids:runtime}
Lo script Python responsabile dell'individuazione dei comportamenti anomali è
l'ultima componente del nostro sistema.

Il suo funzionamento è concettualmente molto semplice: per ogni sequenza in
input ne calcola la distanza di Hamming minima rispetto a tutte le sequenze
presenti nel database. Se la distanza minima supera il valore configurabile
\verb|ALLOWED_MISMATCHES|, di default impostato a 2, la sequenza viene
considerata anomala.

Di seguito riportiamo la funzione atta a calcolare la distanza minima di una
sequenza rispetto a quelle note: per ogni sequenza nota ne calcoliamo la
distanza rispetto a quella in esame, fermandoci se il valore trovato è
inferiore o uguale al numero di differenze concesse. In tal caso, infatti, ci
troviamo di fronte a una sequenza legittima.

\begin{lstlisting}[language=Python]
def min_distance(sequence, known_seqs, distance=distance_xrange):
    minimum = config.SEQUENCE_LENGTHS

    for known in known_seqs:
        val = distance(known, sequence)
        if val <= config.ALLOWED_MISMATCHES:
            return val

        if val < minimum:
            minimum = val

    return minimum
\end{lstlisting}

La funzione distance(), usata per calcolare la distanza di Hamming tra due
sequenze, viene passata come parametro in modo da poterne sperimentare
facilmente varie implementazioni e valutarne l'efficienza come descritto nella
sezione che segue.

\subsubsection{Comparison of various distance algorithms}
Evidentemente, l'operazione eseguita più di frequente a runtime è il calcolo
della distanza tra due sequenze; ne segue che la scelta di un buon algoritmo è
particolarmente importante.

Siamo partiti da una versione molto ``idiomatica'' dell'algoritmo, ma
inefficiente. Il codice che segue itera sugli elementi usando la funzione
zip(), che date due sequenze costruisce la lista delle coppie di eguale
posizione. Costruisce quindi mediante una \emph{list comprehenshion}, da cui il
nome dell'algoritmo, una lista di booleani che assumeranno valore True in caso
di diversità della coppia di elementi e False in caso contrario. A questo
punto, la funzione sum() somma gli elementi della lista e considera False
uguale a 0 e True uguale a 1, ritornando infine la distanza di Hamming.

\begin{lstlisting}[language=Python]
def distance_comprehension(s1, s2):
    return sum([ch1 != ch2 for ch1, ch2 in zip(s1, s2)])
\end{lstlisting}

Per provare a migliorare i tempi di esecuzione abbiamo evitato di costruire una
lista, iterando su una sequenza mediante la funzione \emph{enumerate} e
contando quante volte gli elementi dell'altra differiscono:

\begin{lstlisting}[language=Python]
def distance_enumerate(s1, s2):
    mismatches = 0

    for idx, elem in enumerate(s1):
        if elem != s2[idx]:
            mismatches += 1

    return mismatches
\end{lstlisting}

Come ultima inefficienza eliminabile notiamo che la lunghezza della sequenza è
a noi nota a priori. Non è dunque necessario usare la funzione enumerate(), che
itera su una sequenza ritornando a ogni iterazione indice e valore, ma ci basta
andare da 0 ad N, dove N è la lunghezza delle sequenze, tramite la funzione
\emph{xrange}.

\begin{lstlisting}[language=Python]
def distance_xrange(s1, s2):
    mismatches = 0

    for idx in xrange(config.SEQUENCE_LENGTHS):
        if s1[idx] != s2[idx]:
            mismatches += 1

    return mismatches
\end{lstlisting}

Come benchmark abbiamo scelto di calcolare 100 volte la distanza tra una
sequenza del tutto ``sbagliata'', perché composta solo da syscall inesistenti,
e le sequenze prodotte dagli eseguibili gnome-screensaver e firefox in 4 ore di
raccolta dati. Scegliendo una sequenza composta da sole syscall inesistenti
valutiamo il comportamento degli algoritmi nel caso peggiore, visto che sarà
necessario calcolare la distanza rispetto a tutte le sequenze note.

Il benchmark è stato ripetuto 3 volte e di seguito riportiamo il minore dei
tempi impiegati nel corso delle esecuzioni.

\begin{tabular}{l | c  r}
%\caption{Performance at peak F-measure}
algoritmo       & gnome-screensaver (771)  & firefox (15558) \\
\hline
comprehension   & 1.330 s                  & 28.9 s          \\
enumerate       & 1.061 s                  & 23.3 s          \\
xrange          & 0.99 s                   & 21.3 s          \\
\end{tabular}

Concludiamo dunque che, anche nel caso peggiore, la versione dell'algoritmo che
utilizza la funzione xrange è da preferirsi.

%\pagebreak 

\section{Evaluation of the proposed system}

\subsection{Impact on operating system performances}
Ogni processo può eseguire un numero considerevole di chiamate di sistema al
secondo, che vanno organizzate in sequenze di una data lunghezza.
L'elaborazione di una mole di dati di questo tipo porta in pochi secondi al
superamento delle soglie descritte nel paragrafo \ref{systemtap:overload}. 

Proviamo a compilare lo script presentato nella sezione \ref{ids:systemtap} e
ad eseguirlo:

\begin{lstlisting}
$ stap -p 4 all-sequences.stp -m testallsequences.ko 6

$ time staprun testallsequences.ko > /tmp/sequences
ERROR: probe overhead exceeded threshold
WARNING: Number of errors: 1, skipped probes: 0

real    4m31.789s
user    0m0.028s
sys 0m1.332s
\end{lstlisting}

Lo script ha catturato 1671907 sequenze di 6 chiamate di sistema consecutive in
circa 4 minuti e mezzo prima di venire fermato dalla logica di controllo
dell'overhead. Decisamente troppo poco per riuscire a costruire un database
utilizzabile.

Compilando invece il modulo con \verb|-DSTP_NO_OVERLOAD| è possibile
disabilitare i controlli sull'overhead, consentendo al nostro script di
procedere nell'esecuzione. Ovviamente, però, le operazioni svolte continueranno
a essere parecchio impegnative per il sistema: per evitare di renderlo
inutilizzabile è sufficiente impostare la priorità di scheduling di staprun a
19, in modo da garantire ai processi utente di lavorare senza intoppi.

Si veda, ad esempio, come si è proceduto per lo script che si occupa del
controllo a runtime:
\begin{lstlisting}[language=bash]
#!/bin/sh

nice -n 19 staprun allsequences.ko | nice -n 19 python runtime_check.py
\end{lstlisting}

Così facendo è possibile costruire un database di dimensioni arbitrarie e
verificare la presenza di comportamenti anomali senza per questo rendere
inutilizzabile la macchina in esame.

Ad esempio, in 4 ore siamo stati in grado di costruire un database contenente i
dati di 103 eseguibili per un totale di 69974 sequenze uniche.

Di seguito riportiamo il numero di sequenze uniche identificate per i dieci
eseguibili più ``attivi'':

\begin{tabular}{l c}
%\caption{Performance at peak F-measure}
eseguibile      & sequenze uniche \\
\hline
rhythmbox       & 15622 \\
firefox         & 15558 \\
transmission    & 6987 \\
Xorg            & 5368 \\
evince          & 3306 \\
bash            & 2067 \\
pulseaudio      & 1745 \\
vim             & 1425 \\
gnome-terminal  & 1327 \\
gnome-panel     & 1069 \\
\end{tabular}

\subsection{Identifying anomalous behaviour}
Analizziamo, finalmente, il funzionamento del nostro sistema, sia per quanto
concerne l'individuazione di attacchi e comportamenti di dubbia natura che dal
punto di vista dei falsi positivi, cioè dei comportamenti legittimi
erroneamente ritenuti anomali.

\subsubsection{Rootkit identification}
Un rootkit è una collezione di programmi che, tra le altre cose, vengono
utilizzati da un attaccante che ha ottenuto accesso al sistema per nascondere
l'avvenuta intrusione agli amministratori.

Abbiamo installato la versione dell'eseguibile netstat presente nel rootkit ark
versione 1.0.1 su una macchina protetta dal nostro IDS. Questa versione di
netstat è modificata in modo da non mostrare le connessioni in corso che
rispettano determinati criteri scelti a piacere dall'attaccante. Come criterio
abbiamo scelto di nascondere tutti i server in ascolto sull'indirizzo
127.0.0.1.

Ecco l'output prodotto dall'eseguibile netstat originale:

\begin{lstlisting}
ema@mars:~/Desktop/ark-1.0.1$ sudo netstat.old -napt|grep 127
tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      4294/cupsd      
\end{lstlisting}

Il server TCP cups è dunque in ascolto sulla porta 631, indirizzo 127.0.0.1

Cercando di ottenere la stessa informazione con l'eseguibile netstat fornito
con il rootkit ark non otteniamo invece nessun output, proprio come ci
aspettavamo:

\begin{lstlisting}
ema@mars:~/Desktop/ark-1.0.1$ sudo netstat -napt|grep 127
ema@mars:~/Desktop/ark-1.0.1$ 
\end{lstlisting}

Il nostro IDS identifica il comportamento di netstat come potenzialmente
malizioso, scovando ben quattro sequenze del tutto anomale (sei syscall su
sei):

\begin{lstlisting}
6 netstat ('rt_sigprocmask', 'fork', 'rt_sigaction', 
           'rt_sigaction', 'rt_sigprocmask', 'wait4')
6 netstat ('fork', 'rt_sigaction', 'rt_sigaction', 
           'rt_sigprocmask', 'wait4', 'rt_sigaction')
6 netstat ('rt_sigaction', 'rt_sigaction', 'rt_sigprocmask', 
           'wait4', 'rt_sigaction', 'rt_sigaction')
6 netstat ('rt_sigaction', 'rt_sigprocmask', 'wait4', 
           'rt_sigaction', 'rt_sigaction', 'rt_sigprocmask')
\end{lstlisting}

\subsubsection{Nessus scans}
Nessus è uno strumento per scoprire vulnerabilità su sistemi remoti,
caratterizzato da un gran numero di plugin che consentono di abilitare
controlli di vario genere. Alcuni di questi plugin cercano di sfruttare
vulnerabilità note di servizi quali OpenSSH e Samba in modo a volte piuttosto
invasivo; Nessus è dunque un ottimo banco di prova per il nostro IDS.

Il nostro IDS è stato allenato ad un uso molto basilare dei servizi disponibili
(Cups, Samba e OpenSSH). Via Cups abbiamo stampato un paio di pagine di prova,
Samba è stato usato per la condivisione di uno share Windows e OpenSSH per una
mezza dozzina di accessi da remoto, alcuni a buon fine e altri sbagliando
password.

Abbiamo provato a effettuare una scansione Nessus da remoto, usando tutti i
plugin forniti con l'installazione di default dello scanner.

In tabella sono riassunti i dati relativi agli alert prodotti dal nostro IDS;
per ogni eseguibile riportiamo il numero di sequenze uniche presenti nel
database, il numero di sequenze anomale identificate durante la scansione (con
ripetizioni) ed il numero massimo di mismatch.

\begin{tabular}{l | c | c | c}
servizio      & sequenze uniche & sequenze anomale & numero massimo differenze \\
\hline
\textbf{sshd}          & 1173            & 468                & 5 \\
\textbf{cupsd}         & 1100            & 10                 & 4 \\
\textbf{smbd}          & 864             & 215                & 5 \\
\end{tabular}

\subsubsection{False positives}
È ovviamente possibile che alcuni comportamenti legittimi vengano erroneamente
ritenuti anomali. Per quanto durante la fase di creazione del database ci si
sforzi di riprodurre quanti più casi d'uso comune del sistema, può capitare che
alcuni eseguibili effettuino delle operazioni particolari a runtime, per
esempio per qualche cambiamento nell'ambiente operativo della macchina
analizzata. Supponiamo il caso di una rete casalinga a cui si colleghi una
nuova macchina, non presente durante la fase di creazione del database: il
tentativo da parte di quest'ultima di scoprire la presenza di una stampante di
rete potrebbe essere visto dal demone di stampa del calcolatore sotto controllo
come anomalo.

Per portare un esempio ancor più concreto, in fase di test del sistema abbiamo
modificato uno script usato dalla macchina aggiungendo l'uso del comando sort.
Dopo pochi minuti di analisi, la macchina (chiaramente non sotto attacco) ha
iniziato a produrre i seguenti alert:

\begin{lstlisting}
4 sort ('read', 'read', 'read', 'read', 'read', 'read')
4 sort ('read', 'read', 'read', 'read', 'read', 'read')
4 sort ('read', 'read', 'read', 'read', 'read', 'read')
4 sort ('read', 'read', 'read', 'read', 'read', 'read')
4 sort ('read', 'read', 'read', 'read', 'read', 'read')
\end{lstlisting}

Il comportamento suddetto è perfettamente accettabile; abbiamo dunque fatto
girare lo script di creazione del db, il quale in caso di db già esistente si
limita ad aggiungere le nuove sequenze piuttosto che ripartire da zero,
controllando in seguito tramite l'interprete Python la presenza della sequenza
ritenuta anomala. 

\begin{lstlisting}
ema@mars:~/dev/systemtap-ids-poc$ python
iPython 2.6.2 (release26-maint, Apr 19 2009, 01:56:41) 
[GCC 4.3.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import dbaccess
>>> data = dbaccess.getdata()
>>> print ('read', 'read', 'read', 'read', 'read', 'read') \
    in data.executables['sort']
True
>>> 
\end{lstlisting}

La sequenza è stata aggiunta al database, scongiurando così il verificarsi del
falso positivo causato dal ``nuovo'' utilizzo del comando sort.

\section{Conclusions}
\textbf{SystemTap} è un noto sistema per il tracciamento dinamico del
funzionamento del kernel Linux; questo genere di strumenti consente in modo
relativamente semplice di analizzare nel dettaglio il comportamento di un
sistema operativo in produzione. In questa prova finale abbiamo dimostrato come
sia possibile scrivere degli script SystemTap per individuare determinati tipi
di comportamenti potenzialmente ostili come ad esempio dei portscan.

Abbiamo inoltre sviluppato un \textbf{Anomaly Based Intrusion Detection System}
usando l'analisi di brevi sequenze di chiamate di sistema per individuare i
comportamenti potenzialmente anomali. Il sistema sviluppato, composto
principalmente da uno script SystemTap e una mezza dozzina di script
\textbf{Python}, si è rivelato in grado di riconoscere tentativi di intrusione
da remoto generati tramite lo scanner di sicurezza \textbf{Nessus}, nonché la
presenza di rootkit locali, nella fattispecie \textbf{ark}.

Il sistema è stato rilasciato come software libero secondo i termini della
Apache License, versione 2.0 ed è esaminabile online all'indirizzo seguente:
http://bitbucket.org/ema/systemtap-ids-poc/src/. Per utilizzarlo è sufficiente
scaricarne i sorgenti, disponibili all'indirizzo
http://bitbucket.org/ema/systemtap-ids-poc/downloads/ e seguire il file README.

\pagebreak

\begin{thebibliography}{99}

\bibitem{dtrace2004}
  Bryan M. Cantrill et al.
  \emph{Dynamic Instrumentation of Production Systems}
  Sun Microsystems Inc,
  2004.

\bibitem{vara2005}
  Vara Prasad et al.
  \emph{Locating System Problems Using Dynamic Instrumentation}
  IBM Corp, Red Hat Inc, Intel Corporation,
  2005. 

\bibitem{zannoni2007}
  Elena Zannoni,
  \emph{Linux Tips and Tricks for Developers}
  Oracle Corporation,
  2007.

\bibitem{corbet2007}
  Jonathan Corbet,
  \emph{On DTrace envy}
  Linux Weekly News, 
  August 2007.

\bibitem{arch2005}
  Frank Ch. Eigler, Vara Prasad et al.
  \emph{Architecture of SystemTap: a Linux trace/probe tool}
  Red Hat Inc, IBM Corp,
  July 2005.

\bibitem{manstap}
  The SystemTap Community,
  \emph{stap manual page}
  Red Hat Inc

\bibitem{ibmredbook}
  Bart Jacob, Paul Larson et al.
  \emph{SystemTap: Instrumenting the Linux Kernel for Analyzing Performance and
  Functional Problems}
  IBM Corp,
  2009.

\bibitem{langref}
  The SystemTap Community,
  \emph{SystemTap Language Reference}
  Red Hat Inc, IBM Corp, Intel Corporation,
  2009.

\bibitem{wielaard2009}
  Mark Wielaard,
  \emph{A SystemTap update}
  Linux Weekly News, 
  January 2009.

\bibitem{forrest96}
  Stephanie Forrest, Steven A. Hofmeyr, Anil Somayaji, Thomas A. Longstaff
  \emph{A Sense of Self for Unix Processes}
  University of New Mexico, CERT Coordination Center,
  1996.

\bibitem{hofmeyr97}
  Steven A. Hofmeyr, Stephanie Forrest, Anil Somayaji
  \emph{Intrusion Detection using Sequences of System Calls}
  University of New Mexico,
  1997

\bibitem{warrender99}
  Christina Warrender, Stephanie Forrest, Barak Pearlmutter
  \emph{Detecting Intrusions Using System Calls: Alternative Data Models}
  University of New Mexico,
  1999.

\bibitem{wang}
  Ke Wang, Salvatore J. Stolfo
  \emph{Anomalous Payload-based Network Intrusion Detection}
  Columbia University.

\end{thebibliography}

\end{document}
